<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Exoplanet Classifier</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
  <!-- Font Awesome for enlarge icon -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    /* Fullscreen mode for orbit container */
    .fullscreen {
      position: fixed !important;
      top: 0;
      left: 0;
      width: 100% !important;
      height: 100% !important;
      z-index: 1050;
      background: #ffffff;
    }
    .orbit-container-wrapper {
      position: relative;
    }
    .enlarge-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      z-index: 20;
    }
  </style>
</head>
<body>
<div class="container my-4">
  <h1 class="mb-4">Exoplanet Classification</h1>
  <!-- Classification form -->
  <form action="/predict" method="post" class="mb-4">
    <div class="mb-3">
      <label for="orbital_period" class="form-label">Orbital Period (days)</label>
      <input type="number" step="any" class="form-control" id="orbital_period" name="orbital_period" placeholder="e.g. 365" required>
    </div>
    <div class="mb-3">
      <label for="transit_duration" class="form-label">Transit Duration (hours)</label>
      <input type="number" step="any" class="form-control" id="transit_duration" name="transit_duration" placeholder="e.g. 10" required>
    </div>
    <div class="mb-3">
      <label for="planet_radius" class="form-label">Planet Radius (Earth radii)</label>
      <input type="number" step="any" class="form-control" id="planet_radius" name="planet_radius" placeholder="e.g. 1.0" required>
    </div>
    <!-- Additional features can be added here -->
    <button type="submit" class="btn btn-primary">Classify</button>
  </form>

  <!-- Model insights section -->
  <div class="mb-5">
    <h2>Model Insights</h2>
    <p class="text-muted">The classifier relies on astrophysical features (orbital period, transit duration, planet radius, etc.) to make a decision. Certain phenomena can confuse even the best models:</p>
    <ul>
      <li><strong>Stellar spots or variability</strong> &ndash; surface activity on the host star can mimic transit‑like dips.</li>
      <li><strong>Binary stars</strong> &ndash; eclipsing binaries can produce signals that masquerade as planets.</li>
      <li><strong>Instrument noise</strong> &ndash; spacecraft systematics may lead to false positives.</li>
    </ul>
    <p class="text-muted">Our model also outputs a measure of <em>uncertainty</em> in its predictions via class probabilities. Low confidence may warrant human inspection.</p>
  </div>

  <!-- Real‑time stream view: file upload -->
  <div class="mb-5">
    <h2>Real‑Time Transit Search</h2>
    <p>Upload a light‑curve CSV to perform a real‑time transit search in your browser. The detector highlights candidate dips on‑the‑fly. (This demo uses a placeholder and does not yet implement the Box‑Least‑Squares algorithm.)</p>
    <form action="/upload" method="post" enctype="multipart/form-data">
      <div class="mb-3">
        <label for="lightcurve" class="form-label">Light curve file (CSV)</label>
        <input type="file" class="form-control" id="lightcurve" name="lightcurve" accept=".csv">
      </div>
      <button type="submit" class="btn btn-secondary">Upload and Analyze</button>
    </form>
  </div>

  <!-- Benchmark visualisation -->
  <div class="mb-5">
    <h2>Benchmark Metrics</h2>
    <p>During training, the model was benchmarked on known Kepler/TESS datasets. Below are placeholder graphics illustrating its behaviour. When integrated, these will update automatically as the model improves.</p>
    <div class="row">
      <div class="col-md-6 text-center">
        <h5>Confusion Matrix</h5>
        <img src="{{ url_for('static', filename='img/confusion_matrix.png') }}" alt="Confusion Matrix" class="img-fluid">
      </div>
      <div class="col-md-6 text-center">
        <h5>Calibration Plot</h5>
        <img src="{{ url_for('static', filename='img/calibration_plot.png') }}" alt="Calibration Plot" class="img-fluid">
      </div>
    </div>
  </div>

  <!-- 3D Orbit Viewer -->
  <div class="mb-5">
    <h2>3D Orbit Viewer</h2>
    <p>Visualise the star–planet dance. This WebGL demo reconstructs a simple circular orbit. Use the dropdown to load example orbits from famous NASA datasets (Kepler, K2, TESS) or choose a default orbit.</p>
    <div class="mb-3 row">
      <label for="datasetSelect" class="col-sm-3 col-form-label">Select dataset</label>
      <div class="col-sm-9">
        <select id="datasetSelect" class="form-select">
          <option value="default" selected>Default Orbit</option>
          <option value="kepler">Kepler</option>
          <option value="k2">K2</option>
          <option value="tess">TESS</option>
          <!-- Custom dataset populated from user‑provided light curves -->
          <option value="custom">Custom</option>
        </select>
      </div>
    </div>
    <!-- Planet selector, populated dynamically once a dataset is chosen -->
    <div class="mb-3 row" id="planet-row" style="display: none;">
      <label for="planetSelect" class="col-sm-3 col-form-label">Select planet</label>
      <div class="col-sm-9">
        <select id="planetSelect" class="form-select"></select>
      </div>
    </div>
    <!-- Show all planets toggle -->
    <div class="form-check mb-3">
      <input class="form-check-input" type="checkbox" id="showAllCheckbox">
      <label class="form-check-label" for="showAllCheckbox">Show all planets</label>
    </div>
    <div class="orbit-container-wrapper">
      <button id="orbitFullscreenBtn" class="btn btn-light btn-sm enlarge-btn" title="Toggle full screen"><i class="fas fa-expand"></i></button>
      <div id="orbit-container" style="width: 100%; height: 400px;"></div>
    </div>
    <!-- Link to advanced dataset explorer for 3D visualisation with filters -->
    <div class="mt-3">
      <a href="/explore" class="btn btn-info">Dataset Explorer</a>
    </div>
  </div>
</div>

<!-- Three.js library for 3D orbit viewer -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
  /*
   * Enhanced orbit viewer with real dataset integration.
   * A local JSON file (static/data/exoplanets.json) defines sample exoplanets for
   * Kepler, K2 and TESS missions. When a dataset is selected, the planet
   * dropdown is populated. Selecting a planet updates the orbit radius and speed
   * based on its period and radius. If no dataset is selected (default), a
   * generic orbit is shown.
   */
  function initOrbitViewer() {
    const container = document.getElementById('orbit-container');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);
    // Lighting
    const ambient = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambient);
    // Load textures for star and planet
    const loader = new THREE.TextureLoader();
    const starTexture   = loader.load("{{ url_for('static', filename='textures/star_texture.png') }}");
    const planetTexture = loader.load("{{ url_for('static', filename='textures/planet_texture.png') }}");
    // Star and single planet mesh with realistic materials
    const starMaterial   = new THREE.MeshPhongMaterial({ map: starTexture, emissive: 0xffcc00, emissiveIntensity: 0.8 });
    const planetMaterial = new THREE.MeshPhongMaterial({ map: planetTexture, shininess: 15 });
    const star = new THREE.Mesh(new THREE.SphereGeometry(0.5, 64, 64), starMaterial);
    scene.add(star);
    const singlePlanet = new THREE.Mesh(new THREE.SphereGeometry(0.1, 64, 64), planetMaterial);
    scene.add(singlePlanet);
    // Additional directional light for shading
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    // -------------------------
    // Orbit configuration and state
    // -------------------------
    // Configuration for the selected planet's orbit (default values)
    let orbitConfig = { radius: 3.0, speed: 0.01, color: 0x0088ff };
    // The current angle for the single planet
    let theta = 0;
    // Collection of planet meshes for multi‑planet mode
    let planetMeshes = [];
    // Single orbit trajectory line and collection of lines for all planets
    let singleOrbitLine;
    let orbitLines = [];
    // Flag indicating if we are showing all planets at once
    let showAll = false;

    // Helper to create a circular orbit line in the XZ-plane
    function createOrbitLine(radius, color = 0xffffff) {
      const curve = new THREE.EllipseCurve(
        0, 0, // ax, aY
        radius, radius, // xRadius, yRadius
        0, 2 * Math.PI, // startAngle, endAngle
        false, // clockwise
        0 // rotation
      );
      const points = curve.getPoints(128);
      // Convert 2D points to 3D vectors in XZ-plane
      const geometry = new THREE.BufferGeometry().setFromPoints(points.map(p => new THREE.Vector3(p.x, 0, p.y)));
      const material = new THREE.LineBasicMaterial({ color: color, opacity: 0.3, transparent: true });
      return new THREE.LineLoop(geometry, material);
    }

    // Create initial orbit line for the default single planet
    singleOrbitLine = createOrbitLine(orbitConfig.radius);
    scene.add(singleOrbitLine);

    // Update the single orbit line when the radius changes
    function updateSingleOrbitLine(radius) {
      if (singleOrbitLine) {
        scene.remove(singleOrbitLine);
      }
      singleOrbitLine = createOrbitLine(radius);
      scene.add(singleOrbitLine);
    }

    // Clear all multi-planet orbit lines
    function clearOrbitLines() {
      orbitLines.forEach(line => scene.remove(line));
      orbitLines = [];
    }

    // Create orbit lines for all planets in a dataset
    function updateOrbitLinesForDataset(datasetKey) {
      clearOrbitLines();
      if (!exoplanets || !exoplanets[datasetKey]) return;
      const list = exoplanets[datasetKey];
      list.forEach(entry => {
        const radiusVal = 2.0 + (entry.radius || 1) * 0.5;
        const line = createOrbitLine(radiusVal, 0xffffff);
        line.material.opacity = 0.25;
        scene.add(line);
        orbitLines.push(line);
      });
    }
    // Note: state variables for planets, orbit lines and flags are declared
    // above alongside orbitConfig. Do not redeclare them here.
    // Camera position
    camera.position.set(0, 5, 8);
    camera.lookAt(scene.position);
    // Preserve the original camera position for scaling in fullscreen mode
    let originalCameraPosition = camera.position.clone();
    // Animation loop draws the orbit each frame
    function animate() {
      requestAnimationFrame(animate);
      if (showAll && planetMeshes.length > 0) {
        // Update each planet in the array
        planetMeshes.forEach(item => {
          item.theta += item.speed;
          item.mesh.material.color.setHex(item.color);
          item.mesh.position.set(item.radius * Math.cos(item.theta), 0, item.radius * Math.sin(item.theta));
        });
        // Hide the single planet mesh
        singlePlanet.visible = false;
      } else {
        // Update single planet orbit
        theta += orbitConfig.speed;
        singlePlanet.material.color.setHex(orbitConfig.color);
        singlePlanet.position.set(orbitConfig.radius * Math.cos(theta), 0, orbitConfig.radius * Math.sin(theta));
        singlePlanet.visible = true;
      }
      renderer.render(scene, camera);
    }
    animate();
    // Load exoplanet data from local JSON
    let exoplanets = {};
    fetch("{{ url_for('static', filename='data/exoplanets.json') }}")
      .then(response => response.json())
      .then(data => {
        exoplanets = data;
      })
      .catch(err => {
        console.error('Failed to load exoplanet dataset:', err);
      });
    // Selection elements
    const datasetSelect = document.getElementById('datasetSelect');
    const planetSelect  = document.getElementById('planetSelect');
    const planetRow     = document.getElementById('planet-row');
    const showAllCheckbox = document.getElementById('showAllCheckbox');
    const fullscreenBtn   = document.getElementById('orbitFullscreenBtn');
    // Helper to compute orbit parameters from a planet entry
    function setOrbitFromPlanet(entry, datasetKey) {
      if (!entry) return;
      // Scale orbit radius relative to planet size (arbitrary scaling for visualisation)
      const baseRadius = 2.0;
      orbitConfig.radius = baseRadius + (entry.radius || 1) * 0.5;
      // Speed inversely proportional to period (shorter period = faster orbit)
      const baseSpeed = 0.005;
      orbitConfig.speed = baseSpeed + (entry.period ? (1 / entry.period) * 0.05 : 0.01);
      // Colour by dataset
      const colors = { kepler: 0xff5555, k2: 0x55ff55, tess: 0x5555ff };
      orbitConfig.color = colors[datasetKey] || 0x0088ff;
      // Reset orbit angle so the planet starts at same location when changed
      theta = 0;
      // Update the single orbit trajectory line
      updateSingleOrbitLine(orbitConfig.radius);
    }
    // Helper to clear existing multi-planet meshes
    function clearPlanetMeshes() {
      planetMeshes.forEach(item => {
        scene.remove(item.mesh);
      });
      planetMeshes = [];
    }
    // Helper to create planet meshes for all planets in a dataset
    function updatePlanetMeshesForDataset(datasetKey) {
      clearPlanetMeshes();
      if (!exoplanets || !exoplanets[datasetKey]) return;
      const list = exoplanets[datasetKey];
      // Assign a distinct color to each planet based on its index
      const palette = [0xff5555, 0x55ff55, 0x5555ff, 0xffaa00, 0xaa00ff, 0x00ffaa];
      list.forEach((entry, idx) => {
        const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.08, 32, 32), new THREE.MeshBasicMaterial({ color: palette[idx % palette.length] }));
        // Compute orbit parameters
        const radius = 2.0 + (entry.radius || 1) * 0.5;
        const speed  = 0.005 + (entry.period ? (1 / entry.period) * 0.05 : 0.01);
        scene.add(mesh);
        planetMeshes.push({ mesh: mesh, radius: radius, speed: speed, color: palette[idx % palette.length], theta: 0 });
      });
      // Also update orbit lines for all planets
      updateOrbitLinesForDataset(datasetKey);
    }
    // Populate planet dropdown and update orbit when dataset changes
    if (datasetSelect) {
      datasetSelect.addEventListener('change', function() {
        const datasetKey = this.value;
        if (!exoplanets || !exoplanets[datasetKey] || datasetKey === 'default') {
          // Hide planet selector and revert to default orbit
          planetRow.style.display = 'none';
          orbitConfig = { radius: 3.0, speed: 0.01, color: 0x0088ff };
          // Reset single orbit line
          updateSingleOrbitLine(orbitConfig.radius);
          // Clear multi-planet meshes and orbit lines if they exist
          clearPlanetMeshes();
          clearOrbitLines();
          return;
        }
        // Populate planet options
        const list = exoplanets[datasetKey];
        planetSelect.innerHTML = '';
        list.forEach((obj, idx) => {
          const opt = document.createElement('option');
          opt.value = obj.name;
          opt.textContent = obj.name;
          if (idx === 0) opt.selected = true;
          planetSelect.appendChild(opt);
        });
        planetRow.style.display = '';
        // Set orbit using the first planet by default
        setOrbitFromPlanet(list[0], datasetKey);
        // If showing all planets, update the planet meshes
        if (showAll) {
          updatePlanetMeshesForDataset(datasetKey);
        }
      });
    }
    // Update orbit when planet selection changes
    if (planetSelect) {
      planetSelect.addEventListener('change', function() {
        const datasetKey = datasetSelect.value;
        const selectedName = this.value;
        const list = exoplanets[datasetKey] || [];
        const entry = list.find(obj => obj.name === selectedName);
        setOrbitFromPlanet(entry, datasetKey);
      });
    }
    // Handle show all toggle
    if (showAllCheckbox) {
      showAllCheckbox.addEventListener('change', function() {
        showAll = this.checked;
        const datasetKey = datasetSelect.value;
        if (showAll) {
          // Populate planet meshes and orbit lines for current dataset
          if (datasetKey && exoplanets[datasetKey]) {
            updatePlanetMeshesForDataset(datasetKey);
          }
        } else {
          // Clear multi-planet meshes and orbit lines; reset orbit line for single planet
          clearPlanetMeshes();
          clearOrbitLines();
          updateSingleOrbitLine(orbitConfig.radius);
        }
      });
    }
    // Handle full screen toggle for orbit viewer
    if (fullscreenBtn) {
      fullscreenBtn.addEventListener('click', function() {
        const wrapper = container.parentElement;
        wrapper.classList.toggle('fullscreen');
        // Change icon between expand and compress
        const icon = this.querySelector('i');
        if (wrapper.classList.contains('fullscreen')) {
          icon.classList.remove('fa-expand');
          icon.classList.add('fa-compress');
        } else {
          icon.classList.remove('fa-compress');
          icon.classList.add('fa-expand');
        }
        // Adjust camera distance when toggling fullscreen to enlarge or restore the orbit view
        const isFullscreen = wrapper.classList.contains('fullscreen');
        if (isFullscreen) {
          // Scale down the camera distance to zoom in; smaller values bring the camera closer
          camera.position.set(
            originalCameraPosition.x,
            originalCameraPosition.y * 0.6,
            originalCameraPosition.z * 0.6
          );
        } else {
          // Restore the original camera position
          camera.position.copy(originalCameraPosition);
        }
        camera.lookAt(scene.position);
        // Trigger resize to update renderer dimensions and projection
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });
    }
    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });
  }
  document.addEventListener('DOMContentLoaded', initOrbitViewer);
</script>
</body>
</html>